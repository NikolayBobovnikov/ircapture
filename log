diff --git a/auvir_embed/mocap/receiver/stm32f103/Src/main.c b/auvir_embed/mocap/receiver/stm32f103/Src/main.c
index 75f403f..932ee60 100644
--- a/auvir_embed/mocap/receiver/stm32f103/Src/main.c
+++ b/auvir_embed/mocap/receiver/stm32f103/Src/main.c
@@ -145,8 +145,6 @@ int main(void)
   /* USER CODE BEGIN 2 */
     //TODO: setting the timer. merge with TIM_Init
     setup_ic_timer();
-    //debug_init_gpio();
-    //init_gpio_led();
     nrf24_setup_gpio();
 
     //// start usec delay timer
@@ -351,9 +349,9 @@ void MX_TIM4_Init(void)
 
 }
 
-/** Configure pins as 
-        * Analog 
-        * Input 
+/** Configure pins as
+        * Analog
+        * Input
         * Output
         * EVENT_OUT
         * EXTI
@@ -495,10 +493,10 @@ void assert_failed(uint8_t* file, uint32_t line)
 
 /**
   * @}
-  */ 
+  */
 
 /**
   * @}
-*/ 
+*/
 
 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/auvir_embed/mocap/transmitter/stm32f103/Src/main.c b/auvir_embed/mocap/transmitter/stm32f103/Src/main.c
index 2ad4ec3..b6504cd 100644
--- a/auvir_embed/mocap/transmitter/stm32f103/Src/main.c
+++ b/auvir_embed/mocap/transmitter/stm32f103/Src/main.c
@@ -135,7 +135,6 @@ int main(void)
   MX_USART1_UART_Init();
 
   /* USER CODE BEGIN 2 */
-  debug_init_gpio();
   init_beamer_channels_gpio();
   HAL_TIM_Base_Start_IT(phtim_envelop);      // envelop
   HAL_TIM_PWM_Start(phtim_pwm, TIM_CHANNEL_4);  // pwm
@@ -144,8 +143,6 @@ int main(void)
   // start usec delay timer
   HAL_TIM_Base_Start(&htim2);
 
-  init_gpio_led();
-
   bool is_transmitter = (mode =='t');
   bool is_receiver = !is_transmitter;
 
@@ -157,7 +154,7 @@ int main(void)
   while (1) {
     init_data();
     sensor_send_data();
-    RXX();
+    //RXX();
     //ReceiveDataToSend();
     //HAL_UART_Receive_IT(&huart1, &uart_msg, sizeof(uart_msg));
 
diff --git a/auvir_embed/mocap/usbdevice/stm32f103/Inc/mxconstants.h b/auvir_embed/mocap/usbdevice/stm32f103/Inc/mxconstants.h
index b165934..8ca61bb 100644
--- a/auvir_embed/mocap/usbdevice/stm32f103/Inc/mxconstants.h
+++ b/auvir_embed/mocap/usbdevice/stm32f103/Inc/mxconstants.h
@@ -40,10 +40,8 @@
 
 #define LED_ONBOARD_Pin GPIO_PIN_13
 #define LED_ONBOARD_GPIO_Port GPIOC
-#define NRF_IRQ_Pin GPIO_PIN_4
-#define NRF_IRQ_GPIO_Port GPIOA
-#define DBG_OUT_1_Pin GPIO_PIN_0
-#define DBG_OUT_1_GPIO_Port GPIOB
+#define NRF_IRQ_Pin GPIO_PIN_0
+#define NRF_IRQ_GPIO_Port GPIOB
 #define DBG_OUT_2_Pin GPIO_PIN_1
 #define DBG_OUT_2_GPIO_Port GPIOB
 #define LED_DBG_Pin GPIO_PIN_3
diff --git a/auvir_embed/mocap/usbdevice/stm32f103/Inc/stm32f1xx_it.h b/auvir_embed/mocap/usbdevice/stm32f103/Inc/stm32f1xx_it.h
index 5279942..7c18b50 100644
--- a/auvir_embed/mocap/usbdevice/stm32f103/Inc/stm32f1xx_it.h
+++ b/auvir_embed/mocap/usbdevice/stm32f103/Inc/stm32f1xx_it.h
@@ -52,7 +52,7 @@ void BusFault_Handler(void);
 void UsageFault_Handler(void);
 void DebugMon_Handler(void);
 void SysTick_Handler(void);
-void EXTI4_IRQHandler(void);
+void EXTI0_IRQHandler(void);
 void USB_LP_CAN1_RX0_IRQHandler(void);
 void SPI1_IRQHandler(void);
 
diff --git a/auvir_embed/mocap/usbdevice/stm32f103/Inc/usbd_cdc_if.h b/auvir_embed/mocap/usbdevice/stm32f103/Inc/usbd_cdc_if.h
index ddadf12..d15089a 100644
--- a/auvir_embed/mocap/usbdevice/stm32f103/Inc/usbd_cdc_if.h
+++ b/auvir_embed/mocap/usbdevice/stm32f103/Inc/usbd_cdc_if.h
@@ -34,11 +34,6 @@
 #ifndef __USBD_CDC_IF_H
 #define __USBD_CDC_IF_H
 
-/* Define size for the receive and transmit buffer over CDC */
-/* It's up to user to redefine and/or remove those define */
-#define APP_RX_DATA_SIZE  4
-#define APP_TX_DATA_SIZE  4
-
 #ifdef __cplusplus
  extern "C" {
 #endif
@@ -51,45 +46,47 @@
 /** @addtogroup STM32_USB_OTG_DEVICE_LIBRARY
   * @{
   */
-  
+
 /** @defgroup USBD_CDC_IF
-  * @brief header 
+  * @brief header
   * @{
-  */ 
+  */
 
 /** @defgroup USBD_CDC_IF_Exported_Defines
   * @{
-  */ 
+  */
 /* USER CODE BEGIN EXPORTED_DEFINES */
+#define APP_RX_DATA_SIZE 4
+#define APP_TX_DATA_SIZE 4
 /* USER CODE END EXPORTED_DEFINES */
 
 /**
   * @}
-  */ 
+  */
 
 /** @defgroup USBD_CDC_IF_Exported_Types
   * @{
-  */  
+  */
 /* USER CODE BEGIN EXPORTED_TYPES */
 /* USER CODE END EXPORTED_TYPES */
 
 /**
   * @}
-  */ 
+  */
 
 /** @defgroup USBD_CDC_IF_Exported_Macros
   * @{
-  */ 
+  */
 /* USER CODE BEGIN EXPORTED_MACRO */
 /* USER CODE END EXPORTED_MACRO */
 
 /**
   * @}
-  */ 
+  */
 
 /** @defgroup USBD_AUDIO_IF_Exported_Variables
   * @{
-  */ 
+  */
 extern USBD_CDC_ItfTypeDef  USBD_Interface_fops_FS;
 
 /* USER CODE BEGIN EXPORTED_VARIABLES */
@@ -97,11 +94,11 @@ extern USBD_CDC_ItfTypeDef  USBD_Interface_fops_FS;
 
 /**
   * @}
-  */ 
+  */
 
 /** @defgroup USBD_CDC_IF_Exported_FunctionsPrototype
   * @{
-  */ 
+  */
 uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len);
 
 /* USER CODE BEGIN EXPORTED_FUNCTIONS */
@@ -109,20 +106,20 @@ bool is_usb_configured();
 /* USER CODE END EXPORTED_FUNCTIONS */
 /**
   * @}
-  */ 
+  */
 
 /**
   * @}
-  */ 
+  */
 
 /**
   * @}
-  */ 
-  
+  */
+
 #ifdef __cplusplus
 }
 #endif
-  
+
 #endif /* __USBD_CDC_IF_H */
 
 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/auvir_embed/mocap/usbdevice/stm32f103/Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Src/usbd_cdc.c b/auvir_embed/mocap/usbdevice/stm32f103/Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Src/usbd_cdc.c
index 5560d36..57e8a61 100644
--- a/auvir_embed/mocap/usbdevice/stm32f103/Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Src/usbd_cdc.c
+++ b/auvir_embed/mocap/usbdevice/stm32f103/Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Src/usbd_cdc.c
@@ -4,21 +4,21 @@
   * @author  MCD Application Team
   * @version V2.4.1
   * @date    19-June-2015
-  * @brief   This file provides the high layer firmware functions to manage the 
+  * @brief   This file provides the high layer firmware functions to manage the
   *          following functionalities of the USB CDC Class:
   *           - Initialization and Configuration of high and low layer
   *           - Enumeration as CDC Device (and enumeration for each implemented memory interface)
   *           - OUT/IN data transfer
   *           - Command IN transfer (class requests management)
   *           - Error management
-  *           
+  *
   *  @verbatim
-  *      
-  *          ===================================================================      
+  *
+  *          ===================================================================
   *                                CDC Class Driver Description
-  *          =================================================================== 
+  *          ===================================================================
   *           This driver manages the "Universal Serial Bus Class Definitions for Communications Devices
-  *           Revision 1.2 November 16, 2007" and the sub-protocol specification of "Universal Serial Bus 
+  *           Revision 1.2 November 16, 2007" and the sub-protocol specification of "Universal Serial Bus
   *           Communications Class Subclass Specification for PSTN Devices Revision 1.2 February 9, 2007"
   *           This driver implements the following aspects of the specification:
   *             - Device descriptor management
@@ -28,16 +28,16 @@
   *             - Abstract Control Model compliant
   *             - Union Functional collection (using 1 IN endpoint for control)
   *             - Data interface class
-  * 
+  *
   *           These aspects may be enriched or modified for a specific user application.
-  *          
-  *            This driver doesn't implement the following aspects of the specification 
+  *
+  *            This driver doesn't implement the following aspects of the specification
   *            (but it is possible to manage these features with some modifications on this driver):
   *             - Any class-specific aspect relative to communication classes should be managed by user application.
   *             - All communication classes other than PSTN are not managed
-  *      
+  *
   *  @endverbatim
-  *                                  
+  *
   ******************************************************************************
   * @attention
   *
@@ -49,17 +49,17 @@
   *
   *        http://www.st.com/software_license_agreement_liberty_v2
   *
-  * Unless required by applicable law or agreed to in writing, software 
-  * distributed under the License is distributed on an "AS IS" BASIS, 
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   ******************************************************************************
-  */ 
+  */
 
 /* Includes ------------------------------------------------------------------*/
-#include "USBD_CDC.h"
+#include "usbd_cdc.h"
 #include "usbd_desc.h"
 #include "usbd_ctlreq.h"
 
@@ -69,34 +69,34 @@
   */
 
 
-/** @defgroup USBD_CDC 
+/** @defgroup USBD_CDC
   * @brief usbd core module
   * @{
-  */ 
+  */
 
 /** @defgroup USBD_CDC_Private_TypesDefinitions
   * @{
-  */ 
+  */
 /**
   * @}
-  */ 
+  */
 
 
 /** @defgroup USBD_CDC_Private_Defines
   * @{
-  */ 
+  */
 /**
   * @}
-  */ 
+  */
 
 
 /** @defgroup USBD_CDC_Private_Macros
   * @{
-  */ 
+  */
 
 /**
   * @}
-  */ 
+  */
 
 
 /** @defgroup USBD_CDC_Private_FunctionPrototypes
@@ -104,19 +104,19 @@
   */
 
 
-static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev,
                                uint8_t cfgidx);
 
-static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev,
                                  uint8_t cfgidx);
 
-static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev,
                                 USBD_SetupReqTypedef *req);
 
-static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev,
                                  uint8_t epnum);
 
-static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev,
                                  uint8_t epnum);
 
 static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev);
@@ -148,15 +148,15 @@ __ALIGN_BEGIN static uint8_t USBD_CDC_DeviceQualifierDesc[USB_LEN_DEV_QUALIFIER_
 
 /**
   * @}
-  */ 
+  */
 
 /** @defgroup USBD_CDC_Private_Variables
   * @{
-  */ 
+  */
 
 
 /* CDC interface class callbacks structure */
-USBD_ClassTypeDef  USBD_CDC = 
+USBD_ClassTypeDef  USBD_CDC =
 {
   USBD_CDC_Init,
   USBD_CDC_DeInit,
@@ -167,10 +167,10 @@ USBD_ClassTypeDef  USBD_CDC =
   USBD_CDC_DataOut,
   NULL,
   NULL,
-  NULL,     
-  USBD_CDC_GetHSCfgDesc,  
-  USBD_CDC_GetFSCfgDesc,    
-  USBD_CDC_GetOtherSpeedCfgDesc, 
+  NULL,
+  USBD_CDC_GetHSCfgDesc,
+  USBD_CDC_GetFSCfgDesc,
+  USBD_CDC_GetOtherSpeedCfgDesc,
   USBD_CDC_GetDeviceQualifierDescriptor,
 };
 
@@ -187,9 +187,9 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgHSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x00,   /* iConfiguration: Index of string descriptor describing the configuration */
   0xC0,   /* bmAttributes: self powered */
   0x32,   /* MaxPower 0 mA */
-  
+
   /*---------------------------------------------------------------------------*/
-  
+
   /*Interface Descriptor */
   0x09,   /* bLength: Interface Descriptor size */
   USB_DESC_TYPE_INTERFACE,  /* bDescriptorType: Interface */
@@ -201,34 +201,34 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgHSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x02,   /* bInterfaceSubClass: Abstract Control Model */
   0x01,   /* bInterfaceProtocol: Common AT commands */
   0x00,   /* iInterface: */
-  
+
   /*Header Functional Descriptor*/
   0x05,   /* bLength: Endpoint Descriptor size */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x00,   /* bDescriptorSubtype: Header Func Desc */
   0x10,   /* bcdCDC: spec release number */
   0x01,
-  
+
   /*Call Management Functional Descriptor*/
   0x05,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x01,   /* bDescriptorSubtype: Call Management Func Desc */
   0x00,   /* bmCapabilities: D0+D1 */
   0x01,   /* bDataInterface: 1 */
-  
+
   /*ACM Functional Descriptor*/
   0x04,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x02,   /* bDescriptorSubtype: Abstract Control Management desc */
   0x02,   /* bmCapabilities */
-  
+
   /*Union Functional Descriptor*/
   0x05,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x06,   /* bDescriptorSubtype: Union func desc */
   0x00,   /* bMasterInterface: Communication class interface */
   0x01,   /* bSlaveInterface0: Data Class Interface */
-  
+
   /*Endpoint 2 Descriptor*/
   0x07,                           /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,   /* bDescriptorType: Endpoint */
@@ -236,9 +236,9 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgHSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x03,                           /* bmAttributes: Interrupt */
   LOBYTE(CDC_CMD_PACKET_SIZE),     /* wMaxPacketSize: */
   HIBYTE(CDC_CMD_PACKET_SIZE),
-  0x10,                           /* bInterval: */ 
+  0x10,                           /* bInterval: */
   /*---------------------------------------------------------------------------*/
-  
+
   /*Data class interface descriptor*/
   0x09,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_INTERFACE,  /* bDescriptorType: */
@@ -249,7 +249,7 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgHSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x00,   /* bInterfaceSubClass: */
   0x00,   /* bInterfaceProtocol: */
   0x00,   /* iInterface: */
-  
+
   /*Endpoint OUT Descriptor*/
   0x07,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */
@@ -258,7 +258,7 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgHSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   LOBYTE(CDC_DATA_HS_MAX_PACKET_SIZE),  /* wMaxPacketSize: */
   HIBYTE(CDC_DATA_HS_MAX_PACKET_SIZE),
   0x00,                              /* bInterval: ignore for Bulk transfer */
-  
+
   /*Endpoint IN Descriptor*/
   0x07,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */
@@ -283,9 +283,9 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgFSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x00,   /* iConfiguration: Index of string descriptor describing the configuration */
   0xC0,   /* bmAttributes: self powered */
   0x32,   /* MaxPower 0 mA */
-  
+
   /*---------------------------------------------------------------------------*/
-  
+
   /*Interface Descriptor */
   0x09,   /* bLength: Interface Descriptor size */
   USB_DESC_TYPE_INTERFACE,  /* bDescriptorType: Interface */
@@ -297,34 +297,34 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgFSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x02,   /* bInterfaceSubClass: Abstract Control Model */
   0x01,   /* bInterfaceProtocol: Common AT commands */
   0x00,   /* iInterface: */
-  
+
   /*Header Functional Descriptor*/
   0x05,   /* bLength: Endpoint Descriptor size */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x00,   /* bDescriptorSubtype: Header Func Desc */
   0x10,   /* bcdCDC: spec release number */
   0x01,
-  
+
   /*Call Management Functional Descriptor*/
   0x05,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x01,   /* bDescriptorSubtype: Call Management Func Desc */
   0x00,   /* bmCapabilities: D0+D1 */
   0x01,   /* bDataInterface: 1 */
-  
+
   /*ACM Functional Descriptor*/
   0x04,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x02,   /* bDescriptorSubtype: Abstract Control Management desc */
   0x02,   /* bmCapabilities */
-  
+
   /*Union Functional Descriptor*/
   0x05,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x06,   /* bDescriptorSubtype: Union func desc */
   0x00,   /* bMasterInterface: Communication class interface */
   0x01,   /* bSlaveInterface0: Data Class Interface */
-  
+
   /*Endpoint 2 Descriptor*/
   0x07,                           /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,   /* bDescriptorType: Endpoint */
@@ -332,9 +332,9 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgFSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x03,                           /* bmAttributes: Interrupt */
   LOBYTE(CDC_CMD_PACKET_SIZE),     /* wMaxPacketSize: */
   HIBYTE(CDC_CMD_PACKET_SIZE),
-  0x10,                           /* bInterval: */ 
+  0x10,                           /* bInterval: */
   /*---------------------------------------------------------------------------*/
-  
+
   /*Data class interface descriptor*/
   0x09,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_INTERFACE,  /* bDescriptorType: */
@@ -345,7 +345,7 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgFSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   0x00,   /* bInterfaceSubClass: */
   0x00,   /* bInterfaceProtocol: */
   0x00,   /* iInterface: */
-  
+
   /*Endpoint OUT Descriptor*/
   0x07,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */
@@ -354,7 +354,7 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgFSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   LOBYTE(CDC_DATA_FS_MAX_PACKET_SIZE),  /* wMaxPacketSize: */
   HIBYTE(CDC_DATA_FS_MAX_PACKET_SIZE),
   0x00,                              /* bInterval: ignore for Bulk transfer */
-  
+
   /*Endpoint IN Descriptor*/
   0x07,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */
@@ -366,17 +366,17 @@ __ALIGN_BEGIN uint8_t USBD_CDC_CfgFSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
 } ;
 
 __ALIGN_BEGIN uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
-{ 
+{
   0x09,   /* bLength: Configuation Descriptor size */
-  USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION,   
+  USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION,
   USB_CDC_CONFIG_DESC_SIZ,
   0x00,
   0x02,   /* bNumInterfaces: 2 interfaces */
   0x01,   /* bConfigurationValue: */
   0x04,   /* iConfiguration: */
   0xC0,   /* bmAttributes: */
-  0x32,   /* MaxPower 100 mA */  
-  
+  0x32,   /* MaxPower 100 mA */
+
   /*Interface Descriptor */
   0x09,   /* bLength: Interface Descriptor size */
   USB_DESC_TYPE_INTERFACE,  /* bDescriptorType: Interface */
@@ -388,34 +388,34 @@ __ALIGN_BEGIN uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIG
   0x02,   /* bInterfaceSubClass: Abstract Control Model */
   0x01,   /* bInterfaceProtocol: Common AT commands */
   0x00,   /* iInterface: */
-  
+
   /*Header Functional Descriptor*/
   0x05,   /* bLength: Endpoint Descriptor size */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x00,   /* bDescriptorSubtype: Header Func Desc */
   0x10,   /* bcdCDC: spec release number */
   0x01,
-  
+
   /*Call Management Functional Descriptor*/
   0x05,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x01,   /* bDescriptorSubtype: Call Management Func Desc */
   0x00,   /* bmCapabilities: D0+D1 */
   0x01,   /* bDataInterface: 1 */
-  
+
   /*ACM Functional Descriptor*/
   0x04,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x02,   /* bDescriptorSubtype: Abstract Control Management desc */
   0x02,   /* bmCapabilities */
-  
+
   /*Union Functional Descriptor*/
   0x05,   /* bFunctionLength */
   0x24,   /* bDescriptorType: CS_INTERFACE */
   0x06,   /* bDescriptorSubtype: Union func desc */
   0x00,   /* bMasterInterface: Communication class interface */
   0x01,   /* bSlaveInterface0: Data Class Interface */
-  
+
   /*Endpoint 2 Descriptor*/
   0x07,                           /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT      ,   /* bDescriptorType: Endpoint */
@@ -424,9 +424,9 @@ __ALIGN_BEGIN uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIG
   LOBYTE(CDC_CMD_PACKET_SIZE),     /* wMaxPacketSize: */
   HIBYTE(CDC_CMD_PACKET_SIZE),
   0xFF,                           /* bInterval: */
-  
+
   /*---------------------------------------------------------------------------*/
-  
+
   /*Data class interface descriptor*/
   0x09,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_INTERFACE,  /* bDescriptorType: */
@@ -437,7 +437,7 @@ __ALIGN_BEGIN uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIG
   0x00,   /* bInterfaceSubClass: */
   0x00,   /* bInterfaceProtocol: */
   0x00,   /* iInterface: */
-  
+
   /*Endpoint OUT Descriptor*/
   0x07,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,      /* bDescriptorType: Endpoint */
@@ -446,7 +446,7 @@ __ALIGN_BEGIN uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIG
   0x40,                              /* wMaxPacketSize: */
   0x00,
   0x00,                              /* bInterval: ignore for Bulk transfer */
-  
+
   /*Endpoint IN Descriptor*/
   0x07,   /* bLength: Endpoint Descriptor size */
   USB_DESC_TYPE_ENDPOINT,     /* bDescriptorType: Endpoint */
@@ -459,11 +459,11 @@ __ALIGN_BEGIN uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIG
 
 /**
   * @}
-  */ 
+  */
 
 /** @defgroup USBD_CDC_Private_Functions
   * @{
-  */ 
+  */
 
 /**
   * @brief  USBD_CDC_Init
@@ -472,26 +472,26 @@ __ALIGN_BEGIN uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIG
   * @param  cfgidx: Configuration index
   * @retval status
   */
-static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev,
                                uint8_t cfgidx)
 {
   uint8_t ret = 0;
   USBD_CDC_HandleTypeDef   *hcdc;
-  
-  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
-  {  
+
+  if(pdev->dev_speed == USBD_SPEED_HIGH  )
+  {
     /* Open EP IN */
     USBD_LL_OpenEP(pdev,
                    CDC_IN_EP,
                    USBD_EP_TYPE_BULK,
                    CDC_DATA_HS_IN_PACKET_SIZE);
-    
+
     /* Open EP OUT */
     USBD_LL_OpenEP(pdev,
                    CDC_OUT_EP,
                    USBD_EP_TYPE_BULK,
                    CDC_DATA_HS_OUT_PACKET_SIZE);
-    
+
   }
   else
   {
@@ -500,7 +500,7 @@ static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev,
                    CDC_IN_EP,
                    USBD_EP_TYPE_BULK,
                    CDC_DATA_FS_IN_PACKET_SIZE);
-    
+
     /* Open EP OUT */
     USBD_LL_OpenEP(pdev,
                    CDC_OUT_EP,
@@ -512,27 +512,27 @@ static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev,
                  CDC_CMD_EP,
                  USBD_EP_TYPE_INTR,
                  CDC_CMD_PACKET_SIZE);
-  
-    
+
+
   pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
-  
+
   if(pdev->pClassData == NULL)
   {
-    ret = 1; 
+    ret = 1;
   }
   else
   {
     hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-    
+
     /* Init  physical Interface components */
     ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
-    
+
     /* Init Xfer states */
     hcdc->TxState =0;
     hcdc->RxState =0;
-       
-    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
-    {      
+
+    if(pdev->dev_speed == USBD_SPEED_HIGH  )
+    {
       /* Prepare Out endpoint to receive next packet */
       USBD_LL_PrepareReceive(pdev,
                              CDC_OUT_EP,
@@ -547,8 +547,8 @@ static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev,
                              hcdc->RxBuffer,
                              CDC_DATA_FS_OUT_PACKET_SIZE);
     }
-    
-    
+
+
   }
   return ret;
 }
@@ -560,24 +560,24 @@ static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev,
   * @param  cfgidx: Configuration index
   * @retval status
   */
-static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev,
                                  uint8_t cfgidx)
 {
   uint8_t ret = 0;
-  
+
   /* Open EP IN */
   USBD_LL_CloseEP(pdev,
               CDC_IN_EP);
-  
+
   /* Open EP OUT */
   USBD_LL_CloseEP(pdev,
               CDC_OUT_EP);
-  
+
   /* Open Command IN EP */
   USBD_LL_CloseEP(pdev,
               CDC_CMD_EP);
-  
-  
+
+
   /* DeInit  physical Interface components */
   if(pdev->pClassData != NULL)
   {
@@ -585,7 +585,7 @@ static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev,
     USBD_free(pdev->pClassData);
     pdev->pClassData = NULL;
   }
-  
+
   return ret;
 }
 
@@ -596,12 +596,12 @@ static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev,
   * @param  req: usb requests
   * @retval status
   */
-static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
+static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev,
                                 USBD_SetupReqTypedef *req)
 {
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
   static uint8_t ifalt = 0;
-    
+
   switch (req->bmRequest & USB_REQ_TYPE_MASK)
   {
   case USB_REQ_TYPE_CLASS :
@@ -612,7 +612,7 @@ static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev,
         ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                           (uint8_t *)hcdc->data,
                                                           req->wLength);
-          USBD_CtlSendData (pdev, 
+          USBD_CtlSendData (pdev,
                             (uint8_t *)hcdc->data,
                             req->wLength);
       }
@@ -620,12 +620,12 @@ static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev,
       {
         hcdc->CmdOpCode = req->bRequest;
         hcdc->CmdLength = req->wLength;
-        
-        USBD_CtlPrepareRx (pdev, 
+
+        USBD_CtlPrepareRx (pdev,
                            (uint8_t *)hcdc->data,
                            req->wLength);
       }
-      
+
     }
     else
     {
@@ -637,18 +637,18 @@ static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev,
 
   case USB_REQ_TYPE_STANDARD:
     switch (req->bRequest)
-    {      
+    {
     case USB_REQ_GET_INTERFACE :
       USBD_CtlSendData (pdev,
                         &ifalt,
                         1);
       break;
-      
+
     case USB_REQ_SET_INTERFACE :
       break;
     }
- 
-  default: 
+
+  default:
     break;
   }
   return USBD_OK;
@@ -664,10 +664,10 @@ static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev,
 static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
 {
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-  
+
   if(pdev->pClassData != NULL)
   {
-    
+
     hcdc->TxState = 0;
 
     return USBD_OK;
@@ -686,13 +686,13 @@ static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
   * @retval status
   */
 static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
-{      
+{
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-  
+
   /* Get the received data length */
   hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
-  
-  /* USB data will be immediately processed, this allow next USB traffic being 
+
+  /* USB data will be immediately processed, this allow next USB traffic being
   NAKed till the end of the application Xfer */
   if(pdev->pClassData != NULL)
   {
@@ -716,22 +716,22 @@ static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
   * @retval status
   */
 static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
-{ 
+{
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-  
+
   if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
   {
     ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
                                                       (uint8_t *)hcdc->data,
                                                       hcdc->CmdLength);
-      hcdc->CmdOpCode = 0xFF; 
-      
+      hcdc->CmdOpCode = 0xFF;
+
   }
   return USBD_OK;
 }
 
 /**
-  * @brief  USBD_CDC_GetFSCfgDesc 
+  * @brief  USBD_CDC_GetFSCfgDesc
   *         Return configuration descriptor
   * @param  speed : current device speed
   * @param  length : pointer data length
@@ -744,7 +744,7 @@ static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
 }
 
 /**
-  * @brief  USBD_CDC_GetHSCfgDesc 
+  * @brief  USBD_CDC_GetHSCfgDesc
   *         Return configuration descriptor
   * @param  speed : current device speed
   * @param  length : pointer data length
@@ -757,7 +757,7 @@ static uint8_t  *USBD_CDC_GetHSCfgDesc (uint16_t *length)
 }
 
 /**
-  * @brief  USBD_CDC_GetCfgDesc 
+  * @brief  USBD_CDC_GetCfgDesc
   *         Return configuration descriptor
   * @param  speed : current device speed
   * @param  length : pointer data length
@@ -770,7 +770,7 @@ static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc (uint16_t *length)
 }
 
 /**
-* @brief  DeviceQualifierDescriptor 
+* @brief  DeviceQualifierDescriptor
 *         return Device Qualifier descriptor
 * @param  length : pointer data length
 * @retval pointer to descriptor buffer
@@ -787,17 +787,17 @@ uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor (uint16_t *length)
   * @param  fops: CD  Interface callback
   * @retval status
   */
-uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
+uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev,
                                       USBD_CDC_ItfTypeDef *fops)
 {
   uint8_t  ret = USBD_FAIL;
-  
+
   if(fops != NULL)
   {
     pdev->pUserData= fops;
-    ret = USBD_OK;    
+    ret = USBD_OK;
   }
-  
+
   return ret;
 }
 
@@ -812,11 +812,11 @@ uint8_t  USBD_CDC_SetTxBuffer  (USBD_HandleTypeDef   *pdev,
                                 uint16_t length)
 {
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-  
+
   hcdc->TxBuffer = pbuff;
-  hcdc->TxLength = length;  
-  
-  return USBD_OK;  
+  hcdc->TxLength = length;
+
+  return USBD_OK;
 }
 
 
@@ -830,9 +830,9 @@ uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                    uint8_t  *pbuff)
 {
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-  
+
   hcdc->RxBuffer = pbuff;
-  
+
   return USBD_OK;
 }
 
@@ -844,22 +844,22 @@ uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
   * @retval status
   */
 uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
-{      
+{
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-  
+
   if(pdev->pClassData != NULL)
   {
     if(hcdc->TxState == 0)
     {
       /* Tx Transfer in progress */
       hcdc->TxState = 1;
-      
+
       /* Transmit next packet */
       USBD_LL_Transmit(pdev,
                        CDC_IN_EP,
                        hcdc->TxBuffer,
                        hcdc->TxLength);
-      
+
       return USBD_OK;
     }
     else
@@ -881,14 +881,14 @@ uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
   * @retval status
   */
 uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
-{      
+{
   USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
-  
+
   /* Suspend or Resume USB Out process */
   if(pdev->pClassData != NULL)
   {
-    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
-    {      
+    if(pdev->dev_speed == USBD_SPEED_HIGH  )
+    {
       /* Prepare Out endpoint to receive next packet */
       USBD_LL_PrepareReceive(pdev,
                              CDC_OUT_EP,
@@ -912,14 +912,14 @@ uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
 }
 /**
   * @}
-  */ 
+  */
 
 /**
   * @}
-  */ 
+  */
 
 /**
   * @}
-  */ 
+  */
 
 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/auvir_embed/mocap/usbdevice/stm32f103/Src/main.c b/auvir_embed/mocap/usbdevice/stm32f103/Src/main.c
index 93f18fb..8bc748d 100644
--- a/auvir_embed/mocap/usbdevice/stm32f103/Src/main.c
+++ b/auvir_embed/mocap/usbdevice/stm32f103/Src/main.c
@@ -152,13 +152,13 @@ int main(void)
     memcpy(buf, str, strlen(str));
 
     //wait for usb device is configured
-    while(!is_usb_configured());
-    
+    //while(!is_usb_configured());
+
     while (1)
     {
 #if 1
         if(is_receiver){
-            //RXX() - this is called on IRQ
+            //RXX();// - this is called on IRQ
             nrf_without_this_interrupts_not_work();
         }
         else if(is_transmitter){
@@ -166,7 +166,7 @@ int main(void)
             HAL_Delay(30);
         }
 #endif
-        //HAL_Delay (10);
+        //HAL_Delay (100);
         //CDC_Transmit_FS(buf, strlen(str));
         //HAL_GPIO_TogglePin (GPIOC,GPIO_PIN_13);
   /* USER CODE END WHILE */
@@ -257,9 +257,9 @@ void MX_TIM2_Init(void)
 
 }
 
-/** Configure pins as 
-        * Analog 
-        * Input 
+/** Configure pins as
+        * Analog
+        * Input
         * Output
         * EVENT_OUT
         * EXTI
@@ -282,7 +282,7 @@ void MX_GPIO_Init(void)
   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_RESET);
 
   /*Configure GPIO pin Output Level */
-  HAL_GPIO_WritePin(GPIOB, DBG_OUT_1_Pin|DBG_OUT_2_Pin|LED_DBG_Pin, GPIO_PIN_RESET);
+  HAL_GPIO_WritePin(GPIOB, DBG_OUT_2_Pin|LED_DBG_Pin, GPIO_PIN_RESET);
 
   /*Configure GPIO pin : LED_ONBOARD_Pin */
   GPIO_InitStruct.Pin = LED_ONBOARD_Pin;
@@ -302,15 +302,15 @@ void MX_GPIO_Init(void)
   GPIO_InitStruct.Pull = GPIO_PULLUP;
   HAL_GPIO_Init(NRF_IRQ_GPIO_Port, &GPIO_InitStruct);
 
-  /*Configure GPIO pins : DBG_OUT_1_Pin DBG_OUT_2_Pin LED_DBG_Pin */
-  GPIO_InitStruct.Pin = DBG_OUT_1_Pin|DBG_OUT_2_Pin|LED_DBG_Pin;
+  /*Configure GPIO pins : DBG_OUT_2_Pin LED_DBG_Pin */
+  GPIO_InitStruct.Pin = DBG_OUT_2_Pin|LED_DBG_Pin;
   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 
   /* EXTI interrupt init*/
-  HAL_NVIC_SetPriority(EXTI4_IRQn, 0, 0);
-  HAL_NVIC_EnableIRQ(EXTI4_IRQn);
+  HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
+  HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 
 }
 
@@ -353,10 +353,10 @@ void assert_failed(uint8_t* file, uint32_t line)
 
 /**
   * @}
-  */ 
+  */
 
 /**
   * @}
-*/ 
+*/
 
 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/auvir_embed/mocap/usbdevice/stm32f103/Src/stm32f1xx_it.c b/auvir_embed/mocap/usbdevice/stm32f103/Src/stm32f1xx_it.c
index d312161..5837a49 100644
--- a/auvir_embed/mocap/usbdevice/stm32f103/Src/stm32f1xx_it.c
+++ b/auvir_embed/mocap/usbdevice/stm32f103/Src/stm32f1xx_it.c
@@ -48,7 +48,7 @@ extern PCD_HandleTypeDef hpcd_USB_FS;
 extern SPI_HandleTypeDef hspi1;
 
 /******************************************************************************/
-/*            Cortex-M3 Processor Interruption and Exception Handlers         */ 
+/*            Cortex-M3 Processor Interruption and Exception Handlers         */
 /******************************************************************************/
 
 /**
@@ -73,17 +73,18 @@ void SysTick_Handler(void)
 /******************************************************************************/
 
 /**
-* @brief This function handles EXTI line4 interrupt.
+* @brief This function handles EXTI line0 interrupt.
 */
-void EXTI4_IRQHandler(void)
+void EXTI0_IRQHandler(void)
 {
-  /* USER CODE BEGIN EXTI4_IRQn 0 */
+  /* USER CODE BEGIN EXTI0_IRQn 0 */
     nrf_receive_handler();
-  /* USER CODE END EXTI4_IRQn 0 */
-  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
-  /* USER CODE BEGIN EXTI4_IRQn 1 */
 
-  /* USER CODE END EXTI4_IRQn 1 */
+  /* USER CODE END EXTI0_IRQn 0 */
+  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
+  /* USER CODE BEGIN EXTI0_IRQn 1 */
+
+  /* USER CODE END EXTI0_IRQn 1 */
 }
 
 /**
diff --git a/auvir_embed/mocap/usbdevice/stm32f103/Src/usbd_cdc_if.c b/auvir_embed/mocap/usbdevice/stm32f103/Src/usbd_cdc_if.c
index 27506c1..4698b0d 100644
--- a/auvir_embed/mocap/usbdevice/stm32f103/Src/usbd_cdc_if.c
+++ b/auvir_embed/mocap/usbdevice/stm32f103/Src/usbd_cdc_if.c
@@ -309,5 +309,3 @@ bool is_usb_configured()
 
 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
 
-
-
